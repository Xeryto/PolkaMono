---
phase: 08-notifications
plan: 02
type: execute
wave: 2
depends_on:
  - 08-01
files_modified:
  - packages/frontend/src/components/DashboardHeader.tsx
  - packages/frontend/src/services/api.ts
  - packages/frontend/src/pages/Dashboard.tsx
  - packages/frontend/src/components/OrdersView.tsx
autonomous: true
requirements:
  - NOTIF-01

must_haves:
  truths:
    - "Bell icon in dashboard header shows unread badge when brand has unread notifications"
    - "Clicking bell opens inline dropdown listing up to 20 notifications with icon, text, timestamp"
    - "Opening the dropdown marks all notifications as read (badge clears)"
    - "Clicking a notification item navigates to Orders view and scrolls/highlights the specific referenced order"
  artifacts:
    - path: "packages/frontend/src/components/DashboardHeader.tsx"
      provides: "Bell with unread badge, dropdown list, mark-read on open, order navigation with targetOrderId"
      contains: "NotificationBell"
    - path: "packages/frontend/src/services/api.ts"
      provides: "fetchNotifications() and markNotificationsRead() API calls"
      contains: "fetchNotifications"
    - path: "packages/frontend/src/pages/Dashboard.tsx"
      provides: "targetOrderId state passed to OrdersView and reset after navigation"
      contains: "targetOrderId"
    - path: "packages/frontend/src/components/OrdersView.tsx"
      provides: "Accepts targetOrderId prop and scrolls/highlights that order on mount"
      contains: "targetOrderId"
  key_links:
    - from: "packages/frontend/src/components/DashboardHeader.tsx"
      to: "packages/frontend/src/services/api.ts"
      via: "fetchNotifications() on mount + polling or on-open, markNotificationsRead() on dropdown open"
      pattern: "fetchNotifications|markNotificationsRead"
    - from: "packages/frontend/src/components/DashboardHeader.tsx"
      to: "Dashboard parent (onViewChange + onTargetOrder)"
      via: "onViewChange('orders') + onTargetOrder(notif.order_id) when notification item clicked"
      pattern: "onViewChange.*orders|onTargetOrder"
    - from: "packages/frontend/src/pages/Dashboard.tsx"
      to: "packages/frontend/src/components/OrdersView.tsx"
      via: "targetOrderId prop passed into OrdersView; OrdersView scrolls to that row on mount"
      pattern: "targetOrderId"
---

<objective>
Wire the existing Bell icon in DashboardHeader into a functional notification dropdown: live unread badge, notification list (icon + text + timestamp), mark-read on open, click navigates to Orders and targets the specific order.

Purpose: NOTIF-01 — brand portal notification bell with real data and order-targeted navigation per CONTEXT.md locked decision.
Output: DashboardHeader.tsx with functional notification bell; fetchNotifications/markNotificationsRead in api.ts; targetOrderId state wired from Dashboard to OrdersView.
</objective>

<execution_context>
@/Users/goldp1/.claude/get-shit-done/workflows/execute-plan.md
@/Users/goldp1/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/08-notifications/08-01-SUMMARY.md
@packages/frontend/src/components/DashboardHeader.tsx
@packages/frontend/src/services/api.ts
@packages/frontend/src/context/AuthContext.tsx
@packages/frontend/src/pages/Dashboard.tsx
@packages/frontend/src/components/OrdersView.tsx
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add fetchNotifications and markNotificationsRead to api.ts</name>
  <files>packages/frontend/src/services/api.ts</files>
  <action>
Append two functions to the API service. Follow the existing pattern in api.ts (authenticated fetch with Authorization header from localStorage authToken):

```typescript
export interface NotificationItem {
  id: string;
  type: string;
  message: string;
  order_id: string | null;
  is_read: boolean;
  created_at: string; // ISO datetime string
}

export interface NotificationsResponse {
  notifications: NotificationItem[];
  unread_count: number;
}

export async function fetchNotifications(): Promise<NotificationsResponse> {
  const token = localStorage.getItem('authToken');
  const res = await fetch(`${API_BASE_URL}/api/v1/notifications/`, {
    headers: { Authorization: `Bearer ${token}` },
  });
  if (!res.ok) throw new Error('Failed to fetch notifications');
  return res.json();
}

export async function markNotificationsRead(): Promise<void> {
  const token = localStorage.getItem('authToken');
  await fetch(`${API_BASE_URL}/api/v1/notifications/read`, {
    method: 'POST',
    headers: { Authorization: `Bearer ${token}` },
  });
}
```

Use the same `API_BASE_URL` constant already defined in api.ts.
  </action>
  <verify>
```bash
cd packages/frontend && npx tsc --noEmit 2>&1 | grep -E "api\.ts|error" | head -20
```
  </verify>
  <done>fetchNotifications() and markNotificationsRead() exported from api.ts with correct TypeScript types. No TS errors.</done>
</task>

<task type="auto">
  <name>Task 2: DashboardHeader notification bell + Dashboard targetOrderId wiring + OrdersView scroll</name>
  <files>packages/frontend/src/components/DashboardHeader.tsx, packages/frontend/src/pages/Dashboard.tsx, packages/frontend/src/components/OrdersView.tsx</files>
  <action>
**Part A — DashboardHeader.tsx: full notification bell with order targeting**

The header already imports Bell from lucide-react and uses Radix DropdownMenu. Extend it:

**Add to DashboardHeader props:**
The component already has `onViewChange`. Add `onTargetOrder: (orderId: string | null) => void` to the props type.

**Imports to add:**
```typescript
import { useEffect, useState, useCallback } from "react";
import { fetchNotifications, markNotificationsRead, NotificationItem } from "@/services/api";
import { ShoppingBag, Package, AlertCircle } from "lucide-react";
```

**State and data fetching inside DashboardHeader component:**
```typescript
const [notifications, setNotifications] = useState<NotificationItem[]>([]);
const [unreadCount, setUnreadCount] = useState(0);
const [bellOpen, setBellOpen] = useState(false);

const loadNotifications = useCallback(async () => {
  try {
    const data = await fetchNotifications();
    setNotifications(data.notifications);
    setUnreadCount(data.unread_count);
  } catch {
    // silently fail — bell just shows empty
  }
}, []);

// Poll every 30 seconds for new notifications
useEffect(() => {
  loadNotifications();
  const interval = setInterval(loadNotifications, 30_000);
  return () => clearInterval(interval);
}, [loadNotifications]);

const handleBellOpen = useCallback(async (open: boolean) => {
  setBellOpen(open);
  if (open && unreadCount > 0) {
    try {
      await markNotificationsRead();
      setUnreadCount(0);
      setNotifications(prev => prev.map(n => ({ ...n, is_read: true })));
    } catch {
      // ignore
    }
  }
}, [unreadCount]);
```

**Notification icon helper** (inside component or as local function):
```typescript
function notifIcon(type: string) {
  if (type === "new_order") return <ShoppingBag className="h-4 w-4 text-brown-light shrink-0" />;
  if (type === "return_logged") return <Package className="h-4 w-4 text-orange-400 shrink-0" />;
  return <AlertCircle className="h-4 w-4 text-muted-foreground shrink-0" />;
}

function formatRelativeTime(isoString: string): string {
  const diff = Date.now() - new Date(isoString).getTime();
  const minutes = Math.floor(diff / 60_000);
  if (minutes < 1) return "только что";
  if (minutes < 60) return `${minutes} мин назад`;
  const hours = Math.floor(minutes / 60);
  if (hours < 24) return `${hours} ч назад`;
  return `${Math.floor(hours / 24)} дн назад`;
}
```

**Bell button JSX** — replace the existing static Bell Button with:
```tsx
<DropdownMenu open={bellOpen} onOpenChange={handleBellOpen}>
  <DropdownMenuTrigger asChild>
    <Button variant="ghost" size="icon" className="hover:bg-brown-dark/50 relative">
      <Bell className="h-4 w-4" />
      {unreadCount > 0 && (
        <span className="absolute -top-1 -right-1 bg-red-500 text-white text-[10px] font-bold rounded-full min-w-[16px] h-4 flex items-center justify-center px-1">
          {unreadCount > 99 ? "99+" : unreadCount}
        </span>
      )}
    </Button>
  </DropdownMenuTrigger>
  <DropdownMenuContent align="end" className="w-80 bg-[hsl(var(--card-custom))] border-brown-light/40 text-card-foreground shadow-lg">
    <DropdownMenuLabel className="flex items-center gap-2">
      <Bell className="h-4 w-4" /> Уведомления
    </DropdownMenuLabel>
    <DropdownMenuSeparator />
    {notifications.length === 0 ? (
      <div className="px-3 py-4 text-sm text-muted-foreground text-center">
        Нет уведомлений
      </div>
    ) : (
      notifications.map((notif) => (
        <DropdownMenuItem
          key={notif.id}
          className={`flex items-start gap-2 px-3 py-2 cursor-pointer ${!notif.is_read ? "bg-brown-dark/10" : ""}`}
          onSelect={() => {
            onTargetOrder(notif.order_id ?? null);
            onViewChange("orders");
          }}
        >
          {notifIcon(notif.type)}
          <div className="flex-1 min-w-0">
            <p className="text-sm leading-snug">{notif.message}</p>
            <p className="text-xs text-muted-foreground mt-0.5">{formatRelativeTime(notif.created_at)}</p>
          </div>
        </DropdownMenuItem>
      ))
    )}
  </DropdownMenuContent>
</DropdownMenu>
```

Keep the existing user dropdown DropdownMenu unchanged — it's a separate Radix DropdownMenu instance.

The `onViewChange` prop already exists on DashboardHeader. Verify `"orders"` is a valid DashboardView union member in Dashboard.tsx and DashboardHeader.tsx.

---

**Part B — Dashboard.tsx: targetOrderId state**

In `packages/frontend/src/pages/Dashboard.tsx`:
1. Add `targetOrderId` state: `const [targetOrderId, setTargetOrderId] = useState<string | null>(null);`
2. Pass `onTargetOrder={setTargetOrderId}` to `<DashboardHeader />`.
3. Pass `targetOrderId={targetOrderId}` to `<OrdersView />` (wherever OrdersView is rendered based on `currentView === 'orders'`).
4. After navigating to orders via the bell (i.e., when `onViewChange("orders")` is triggered from the bell), the targetOrderId is already set. Reset it after OrdersView mounts: pass `onTargetConsumed={() => setTargetOrderId(null)}` to OrdersView so it can clear it after scrolling.

---

**Part C — OrdersView.tsx: scroll/highlight on mount**

Add `targetOrderId?: string | null` and `onTargetConsumed?: () => void` to OrdersView props.

On mount (useEffect with `[targetOrderId]` dependency), if `targetOrderId` is set:
1. Find the order row element. Give each order row a `data-order-id={order.id}` attribute (or an `id={`order-${order.id}`}` attribute).
2. Use `document.querySelector(`[data-order-id="${targetOrderId}"]`)?.scrollIntoView({ behavior: 'smooth', block: 'center' })` to scroll it into view.
3. Apply a brief highlight: add a CSS class (e.g., `ring-2 ring-brown-light`) to the row for 2 seconds, then remove it.
4. Call `onTargetConsumed?.()` after scrolling so Dashboard resets the state.

```typescript
useEffect(() => {
  if (!targetOrderId) return;
  const el = document.querySelector(`[data-order-id="${targetOrderId}"]`);
  if (el) {
    el.scrollIntoView({ behavior: 'smooth', block: 'center' });
    el.classList.add('ring-2', 'ring-brown-light', 'transition-all');
    const timer = setTimeout(() => {
      el.classList.remove('ring-2', 'ring-brown-light');
      onTargetConsumed?.();
    }, 2000);
    return () => clearTimeout(timer);
  } else {
    onTargetConsumed?.();
  }
}, [targetOrderId, onTargetConsumed]);
```

Read OrdersView.tsx first to understand how order rows are rendered (map over orders array) and add `data-order-id` to the correct element (the outer row div/card).
  </action>
  <verify>
```bash
cd packages/frontend && npx tsc --noEmit 2>&1 | head -30
# Also: yarn workspace polka-frontend build (or vite build) to confirm no build errors
```
  </verify>
  <done>Bell shows unread badge when unread notifications exist. Dropdown opens with list (icon + message + relative timestamp). Opening dropdown fires markNotificationsRead() and clears badge. Clicking notification calls onTargetOrder(order_id) then onViewChange("orders"); OrdersView scrolls to and briefly highlights the targeted order row. Empty state shows "Нет уведомлений". 30s polling. No TypeScript errors.</done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit` in packages/frontend passes with no errors
2. Bell dropdown renders with Radix DropdownMenu styling consistent with rest of portal
3. `fetchNotifications` and `markNotificationsRead` functions exported from api.ts
4. On dropdown open: POST /api/v1/notifications/read fires (visible in network tab), badge clears
5. Clicking notification item changes view to "orders" and scrolls to the targeted order row (highlighted for 2s)
</verification>

<success_criteria>
- Bell icon in DashboardHeader shows numeric badge when unread_count > 0
- Opening dropdown calls markNotificationsRead() and resets badge to 0
- Notifications listed as: icon + message + relative timestamp
- Empty state shown when no notifications
- Clicking item calls onViewChange("orders") and scrolls OrdersView to the referenced order with a brief ring highlight
- 30-second polling keeps badge fresh
- No TypeScript compilation errors
</success_criteria>

<output>
After completion, create `.planning/phases/08-notifications/08-02-SUMMARY.md`
</output>
