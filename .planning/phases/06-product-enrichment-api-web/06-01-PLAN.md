---
phase: 06-product-enrichment-api-web
plan: "01"
type: execute
wave: 1
depends_on: []
files_modified:
  - packages/api/models.py
  - packages/api/schemas.py
  - packages/api/main.py
  - packages/api/alembic/versions/<migration_file>
autonomous: true
requirements:
  - PROD-01
  - PROD-03
  - PROD-04
  - PROD-06

must_haves:
  truths:
    - "Product model has sale_price (Float nullable) and sale_type (String(10) nullable) columns"
    - "Product model has sizing_table_image (String nullable) column for S3 URL"
    - "GET /api/v1/brands/products returns sale_price, sale_type, sizing_table_image, delivery_time_min, delivery_time_max per product"
    - "PUT /api/v1/brands/products/{id} accepts sale_price, sale_type, sizing_table_image and persists them"
    - "PUT /api/v1/brands/products/{id} with sale_price=null and sale_type=null clears the sale"
    - "Alembic migration applied cleanly"
  artifacts:
    - path: packages/api/models.py
      contains: "sale_price"
    - path: packages/api/models.py
      contains: "sizing_table_image"
    - path: packages/api/schemas.py
      contains: "sale_price"
    - path: packages/api/alembic/versions
      provides: "migration adding sale_price, sale_type, sizing_table_image to products"
  key_links:
    - from: packages/api/schemas.py ProductUpdateRequest
      to: packages/api/main.py update_product
      via: "setattr fallthrough in for field, value in product_data.dict(exclude_unset=True).items()"
      pattern: "sale_price"
    - from: packages/api/main.py product_to_schema
      to: packages/api/schemas.py Product
      via: "sale_price/sale_type/sizing_table_image/delivery_time_min/max in explicit kwargs"
      pattern: "sale_price=product.sale_price"
---

<objective>
Add sale_price, sale_type, sizing_table_image columns to the Product model; expose them in Pydantic schemas and product_to_schema; also backfill delivery_time_min/max into product_to_schema (they were set on create/update in Phase 5 but not returned); run Alembic migration.

Purpose: The web portal needs these fields before the sale-setting and sizing-table-upload UX can be built.
Output: New DB columns, updated schemas, updated product_to_schema, migration applied.
</objective>

<execution_context>
@/Users/goldp1/.claude/get-shit-done/workflows/execute-plan.md
@/Users/goldp1/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@packages/api/models.py
@packages/api/schemas.py
@packages/api/main.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add sale_price, sale_type, sizing_table_image columns to Product model</name>
  <files>packages/api/models.py</files>
  <action>
In the `Product` class (after `delivery_time_max` on line 269), add three new columns:

```python
sale_price = Column(Float, nullable=True)        # Reduced price (exact) or discount pct; None = no sale
sale_type = Column(String(10), nullable=True)     # 'percent' or 'exact'; None when no active sale
sizing_table_image = Column(String, nullable=True)  # S3 public URL of sizing table image
```

When `sale_type='percent'`, `sale_price` stores the discount percentage (e.g. 20 for 20% off).
When `sale_type='exact'`, `sale_price` stores the final reduced price in rubles.
`sizing_table_image` uses the same pattern as `general_images` entries (S3 public URL string).
  </action>
  <verify>grep -n "sale_price\|sale_type\|sizing_table_image" /Users/goldp1/Polka/packages/api/models.py</verify>
  <done>Three new nullable columns appear on the Product class; grep returns 3 lines in models.py</done>
</task>

<task type="auto">
  <name>Task 2: Update Pydantic schemas and run Alembic migration</name>
  <files>packages/api/schemas.py</files>
  <action>
**In `ProductCreateRequest`** (after `delivery_time_max` on line 247), add:
```python
sale_price: Optional[float] = None
sale_type: Optional[str] = Field(None, pattern=r"^(percent|exact)$")
sizing_table_image: Optional[str] = None
```

Add a new `@field_validator` for sale_price (using the already-imported `field_validator`):
```python
@field_validator("sale_price", mode="before")
@classmethod
def validate_sale_price(cls, v):
    if v is not None and v <= 0:
        raise ValueError("Цена со скидкой должна быть больше нуля")
    return v
```

Extend the existing `require_at_least_one_image` model_validator in `ProductCreateRequest` — add at the end of its body (after the delivery_time check):
```python
if self.sale_price is not None and self.sale_type is None:
    raise ValueError("sale_type обязателен при указании sale_price")
```

**In `ProductUpdateRequest`** (after `delivery_time_max` on line 283), add the same three optional fields. Also extend the `require_at_least_one_image_if_provided` model_validator with the same sale consistency check.

**In `Product` (response schema)** (after `delivery_time_max` on line 320), add:
```python
sale_price: Optional[float] = None
sale_type: Optional[str] = None
sizing_table_image: Optional[str] = None
```

**Run Alembic migration** from `/Users/goldp1/Polka/packages/api/`:
```bash
cd /Users/goldp1/Polka/packages/api && make db-migration message='add sale price and sizing table to products'
cd /Users/goldp1/Polka/packages/api && make db-migrate
```
  </action>
  <verify>
cd /Users/goldp1/Polka/packages/api && python -c "import schemas; print('schemas ok')"
grep -c "sale_price" /Users/goldp1/Polka/packages/api/schemas.py
  </verify>
  <done>
- `python -c "import schemas"` exits 0
- `make db-migrate` exits 0; migration applied
- `grep -c "sale_price" schemas.py` returns ≥ 4 (Create, Update, response, validator)
  </done>
</task>

<task type="auto">
  <name>Task 3: Update product_to_schema to return all enrichment fields</name>
  <files>packages/api/main.py</files>
  <action>
Update `product_to_schema()` (lines 124-155) to include the new fields. The function currently ends with `general_images=product.general_images or []`. Add before the closing `)`:

```python
delivery_time_min=product.delivery_time_min,
delivery_time_max=product.delivery_time_max,
sale_price=product.sale_price,
sale_type=product.sale_type,
sizing_table_image=product.sizing_table_image,
```

NOTE: `delivery_time_min/max` were added to the Product schema in Phase 5 but were never added to `product_to_schema` — add them here too. This fixes a pre-existing gap.

The `update_product` route already handles new scalar fields automatically via its `setattr(product, field, value)` fallthrough loop (`for field, value in product_data.dict(exclude_unset=True).items()`). No changes needed there for `sale_price`, `sale_type`, or `sizing_table_image`.

The `create_product` route manually sets fields after `delivery_time_max` (lines 1698-1699). Add after those lines:
```python
product.sale_price = product_data.sale_price
product.sale_type = product_data.sale_type
product.sizing_table_image = product_data.sizing_table_image
```

Verify:
```bash
cd /Users/goldp1/Polka/packages/api && python -c "import main; print('main ok')"
grep -n "sale_price\|sizing_table_image" /Users/goldp1/Polka/packages/api/main.py
```
  </action>
  <verify>
cd /Users/goldp1/Polka/packages/api && python -c "import main; print('ok')"
grep -n "sale_price" /Users/goldp1/Polka/packages/api/main.py
  </verify>
  <done>
- `python -c "import main"` exits 0
- `grep` returns hits in product_to_schema and create_product
- `GET /api/v1/brands/products` response includes `sale_price`, `sale_type`, `sizing_table_image`, `delivery_time_min`, `delivery_time_max` (all null for existing products)
  </done>
</task>

</tasks>

<verification>
```bash
cd /Users/goldp1/Polka/packages/api
python -c "import models, schemas, main; print('all imports ok')"
make db-migrate  # should report "Already at head" or "Running upgrade"

# With API running:
# Set sale on a product
curl -s -X PUT http://localhost:8000/api/v1/brands/products/$PRODUCT_ID \
  -H "Authorization: Bearer $TOKEN" \
  -H "Content-Type: application/json" \
  -d '{"sale_price": 1500, "sale_type": "exact"}' | python3 -m json.tool
# Expect: sale_price: 1500, sale_type: "exact"

# Clear sale
curl -s -X PUT http://localhost:8000/api/v1/brands/products/$PRODUCT_ID \
  -H "Authorization: Bearer $TOKEN" \
  -H "Content-Type: application/json" \
  -d '{"sale_price": null, "sale_type": null}' | python3 -m json.tool
# Expect: sale_price: null, sale_type: null
```
</verification>

<success_criteria>
1. Migration applied; products table has `sale_price` (float), `sale_type` (varchar 10), `sizing_table_image` (text) — all nullable.
2. `GET /api/v1/brands/products` returns all five enrichment fields: `sale_price`, `sale_type`, `sizing_table_image`, `delivery_time_min`, `delivery_time_max`.
3. Setting sale persists and echoes back correctly.
4. Sending `null` for `sale_price`/`sale_type` clears the sale.
5. All Python imports clean.
</success_criteria>

<output>
After completion, create `.planning/phases/06-product-enrichment-api-web/06-01-SUMMARY.md` summarizing exact field names, migration filename, and the product_to_schema delivery_time backfill.
</output>
